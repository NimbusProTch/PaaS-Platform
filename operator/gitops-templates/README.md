# GitOps Templates for PaaS Platform Operator

## Overview

This directory contains templates that the PaaS platform operator uses to dynamically generate GitOps configurations for different environments. The operator uses these templates to create a 3-level structure:

1. **Root Apps** (created by Terraform) →
2. **ApplicationSets** (created by operator) →
3. **K8s Manifests** (created by operator)

## Directory Structure

```
gitops-templates/
├── templates/
│   ├── appset-template.yaml.tpl         # ApplicationSet template
│   ├── platform/                        # Platform app templates (PostgreSQL, Redis, RabbitMQ)
│   │   ├── postgresql/
│   │   │   ├── values-nonprod.yaml.tpl  # PostgreSQL nonprod values
│   │   │   └── values-prod.yaml.tpl     # PostgreSQL production values
│   │   ├── redis/
│   │   │   ├── values-nonprod.yaml.tpl  # Redis nonprod values
│   │   │   └── values-prod.yaml.tpl     # Redis production values
│   │   └── rabbitmq/
│   │       ├── values-nonprod.yaml.tpl  # RabbitMQ nonprod values
│   │       └── values-prod.yaml.tpl     # RabbitMQ production values
│   └── business/                        # Business app templates
│       ├── microservice-values.yaml.tpl # Generic microservice values template
│       └── chart-template.yaml.tpl      # Helm Chart.yaml template
└── environments/                        # Generated by operator (not in template repo)
    ├── nonprod/                         # NonProd environment (dev, qa, sandbox)
    └── prod/                            # Production environment
```

## Template Variables

### ApplicationSet Template Variables

- `Environment`: Environment name (dev, qa, sandbox, prod)
- `GitopsRepoURL`: Git repository URL
- `GitopsRepoBranch`: Git branch name
- `Project`: ArgoCD project name
- `AutoSync`: Enable auto-sync (true for nonprod, false for prod)

### Platform App Template Variables

Common variables for all platform apps:
- `Environment`: Environment name
- `DatabaseName`: Database name
- `DatabaseUser`: Database username
- `DatabasePassword`: Database password (from secrets)
- `PrometheusEnabled`: Enable Prometheus metrics

PostgreSQL specific:
- `PostgresPassword`: PostgreSQL admin password

Redis specific:
- `RedisPassword`: Redis password

RabbitMQ specific:
- `RabbitMQUser`: RabbitMQ username
- `RabbitMQPassword`: RabbitMQ password
- `ErlangCookie`: Erlang cookie for clustering

### Business App Template Variables

- `ServiceName`: Microservice name
- `Environment`: Environment name
- `ImageRepository`: Docker image repository URL
- `ImageTag`: Docker image tag
- `ServicePort`: Service port
- `Domain`: Domain name for ingress
- `ReplicaCount`: Number of replicas
- `PostgresEnabled`: Enable PostgreSQL connection
- `RedisEnabled`: Enable Redis connection
- `RabbitMQEnabled`: Enable RabbitMQ connection
- `ResourceLimitsCPU`: CPU limits
- `ResourceLimitsMemory`: Memory limits
- `ResourceRequestsCPU`: CPU requests
- `ResourceRequestsMemory`: Memory requests

## Operator Workflow

### 1. Environment Request Processing

When a new environment is requested (e.g., through a CRD), the operator:

1. Reads the environment specification
2. Determines if it's nonprod (dev/qa/sandbox) or prod
3. Generates ApplicationSet from template
4. Creates environment folder structure in GitOps repo

### 2. ApplicationSet Generation

```go
// Example Go code for operator
func generateApplicationSet(env Environment) {
    tmpl := loadTemplate("appset-template.yaml.tpl")
    data := map[string]interface{}{
        "Environment":      env.Name,
        "GitopsRepoURL":   env.GitopsRepo,
        "GitopsRepoBranch": env.Branch,
        "Project":         env.Project,
        "AutoSync":        env.IsNonProd(),
    }
    output := executeTemplate(tmpl, data)
    saveToGitops(fmt.Sprintf("environments/%s/appset.yaml", env.Type), output)
}
```

### 3. Platform App Deployment

When platform apps are requested:

```go
func deployPlatformApp(app PlatformApp, env Environment) {
    templateFile := fmt.Sprintf("platform/%s/values-%s.yaml.tpl",
        app.Type, env.GetEnvironmentType())

    tmpl := loadTemplate(templateFile)
    data := map[string]interface{}{
        "Environment":      env.Name,
        "DatabaseName":    app.DatabaseName,
        "DatabasePassword": generateSecret(),
        // ... other variables
    }

    output := executeTemplate(tmpl, data)
    path := fmt.Sprintf("environments/%s/platform-apps/%s/values.yaml",
        env.Name, app.Type)
    saveToGitops(path, output)
}
```

### 4. Business App Deployment

When microservices are deployed:

```go
func deployMicroservice(service Microservice, env Environment) {
    tmpl := loadTemplate("business/microservice-values.yaml.tpl")
    data := map[string]interface{}{
        "ServiceName":      service.Name,
        "Environment":      env.Name,
        "ImageRepository":  service.ImageRepo,
        "ImageTag":        service.Tag,
        "PostgresEnabled": service.NeedsPostgres,
        "RedisEnabled":    service.NeedsRedis,
        // ... other variables
    }

    output := executeTemplate(tmpl, data)
    path := fmt.Sprintf("environments/%s/business-apps/%s/values.yaml",
        env.Name, service.Name)
    saveToGitops(path, output)
}
```

## GitOps Repository Structure (Generated)

The operator generates and pushes the following structure to the GitOps repository:

```
gitops-repo/
├── environments/
│   ├── nonprod/
│   │   ├── appset.yaml                  # ApplicationSet for nonprod
│   │   ├── dev/
│   │   │   ├── platform-apps/
│   │   │   │   ├── postgresql/
│   │   │   │   │   └── values.yaml
│   │   │   │   ├── redis/
│   │   │   │   │   └── values.yaml
│   │   │   │   └── rabbitmq/
│   │   │   │       └── values.yaml
│   │   │   └── business-apps/
│   │   │       ├── user-service/
│   │   │       │   └── values.yaml
│   │   │       ├── product-service/
│   │   │       │   └── values.yaml
│   │   │       └── ...
│   │   ├── qa/
│   │   │   └── ... (similar structure)
│   │   └── sandbox/
│   │       └── ... (similar structure)
│   └── prod/
│       ├── appset.yaml                  # ApplicationSet for prod
│       ├── platform-apps/
│       │   └── ... (similar structure)
│       └── business-apps/
│           └── ... (similar structure)
```

## Template Processing

The operator uses Go's text/template package with custom functions:

```go
funcMap := template.FuncMap{
    "default": func(def, val interface{}) interface{} {
        if val == nil || val == "" {
            return def
        }
        return val
    },
    "b64enc": base64.StdEncoding.EncodeToString,
    "indent": func(spaces int, v string) string {
        pad := strings.Repeat(" ", spaces)
        return pad + strings.Replace(v, "\n", "\n"+pad, -1)
    },
}
```

## Security Considerations

1. **Secrets Management**:
   - Passwords are generated and stored in Kubernetes secrets
   - Never hardcode sensitive values in templates
   - Use SecretKeyRef for environment variables

2. **Network Policies**:
   - Templates include network policies by default
   - Restrict traffic between namespaces
   - Allow only necessary ingress/egress

3. **RBAC**:
   - Service accounts with minimal permissions
   - Pod security contexts enforced
   - Non-root containers

## Environment-Specific Settings

### NonProd (dev, qa, sandbox)
- Auto-sync enabled
- Lower resource limits
- Relaxed network policies
- Single replicas for databases
- No backup requirements

### Production
- Manual sync (no auto-sync)
- Higher resource limits
- Strict network policies
- Multi-replica databases
- Backup enabled
- Anti-affinity rules enforced

## Extending Templates

To add a new platform app or customize existing ones:

1. Create template files in appropriate directory
2. Define required variables
3. Update operator code to use new templates
4. Test in nonprod environment first
5. Document variables in this README

## Testing Templates

Before deploying to production:

1. Test template rendering locally
2. Validate generated YAML syntax
3. Deploy to dev environment
4. Run integration tests
5. Promote through qa → sandbox → prod